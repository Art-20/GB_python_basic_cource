# 3. Есть два файла: в одном хранятся ФИО пользователей сайта, а в другом — данные об их хобби.
# Известно, что при хранении данных используется принцип:
# одна строка — один пользователь, разделитель между значениями — запятая.
# Написать код, загружающий данные из обоих файлов и формирующий из них словарь:
# ключи — ФИО, значения — данные о хобби. Сохранить словарь в файл. Проверить сохранённые данные.
# Если в файле, хранящем данные о хобби, меньше записей, чем в файле с ФИО, задаём в словаре значение None.
# Если наоборот — выходим из скрипта с кодом «1». При решении задачи считать, что объём данных в файлах во много раз меньше объема ОЗУ.
# Фрагмент файла с данными о пользователях (users.csv):
# Иванов,Иван,Иванович
# Петров,Петр,Петрович
# Фрагмент файла с данными о хобби (hobby.csv):
# скалолазание,охота
# горные лыжи


import sys
import json


def prepare_dataset(path_users_file: str, path_hobby_file: str) -> dict:
    """
    Считывает данные из файлов и возвращает словарь, где:
        ключ — ФИО, значение — данные о хобби (список строковых переменных)
    :param path_users_file: путь до файла, содержащий ФИО пользователей, разделенных запятой по строке
    :param path_hobby_file: путь до файла, содержащий хобби, разделенные запятой по строке
    :return: Dict(str: Union[List[str]|None])
    """
    #формируем список ключей словаря- ФИО
    key = []
    with open(path_users_file, 'r', encoding='utf-8') as file_1:
        for line in file_1:
            key.append(line.strip())
    # формируем список значений словаря - хобби
    val = []
    with open(path_hobby_file, 'r', encoding='utf-8') as file_2:
        for line in file_2:
            val.append(line.strip())
    #выходим из скрипта с кодом «1», если список хобби больше списка ФИО
    if len(key) < len(val):
        exit(1)
    # формируем словарь -  ФИО: хобби
    dict_prepare = {}
    for _ in range(len(key)):
        if _ <= len(val)-1:
            dict_prepare[key[_]] = val[_]
        # если список ФИО больше списка хобби, задаём в словаре значение None
        else:
            dict_prepare[key[_]] = None

    return dict_prepare


dict_out = prepare_dataset('users.csv', 'hobby.csv')
with open('task_6_3_result.json', 'w', encoding='utf-8') as fw:
    json.dump(dict_out, fw, ensure_ascii=False, indent=2)